"""
PawPal Composite Microservice.

This service encapsulates and exposes the atomic microservices:
- Walk Service
- User Service  
- Review Service

Features:
- Delegates to atomic microservices
- Parallel execution using threads
- Logical foreign key constraint validation
- OpenAPI documentation (auto-generated by FastAPI)
"""
from __future__ import annotations

import os
from contextlib import asynccontextmanager
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Optional, Dict, Any
from uuid import UUID

from fastapi import FastAPI, HTTPException, Query, Depends
from fastapi.responses import JSONResponse

from clients.walk_client import WalkServiceClient
from clients.review_client import ReviewServiceClient
from clients.user_client import UserServiceClient
from constraints import (
    validate_walk_exists,
    validate_review_foreign_keys,
    ForeignKeyConstraintError
)
from models.walk import WalkCreate, WalkRead, WalkUpdate
from models.review import ReviewCreate, ReviewUpdate, Review
from models.user import User, Dog

# Environment variables
port = int(os.environ.get("COMPOSITE_PORT", 8002))
walk_service_url = os.getenv("WALK_SERVICE_URL", "http://localhost:8000")
review_service_url = os.getenv("REVIEW_SERVICE_URL", "http://localhost:8001")
user_service_url = os.getenv("USER_SERVICE_URL", "http://localhost:3001")

# Global client instances
walk_client: Optional[WalkServiceClient] = None
review_client: Optional[ReviewServiceClient] = None
user_client: Optional[UserServiceClient] = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Manage the lifecycle of HTTP clients."""
    global walk_client, review_client, user_client
    walk_client = WalkServiceClient(base_url=walk_service_url)
    review_client = ReviewServiceClient(base_url=review_service_url)
    user_client = UserServiceClient(base_url=user_service_url)
    yield
    await walk_client.close()
    await review_client.close()
    await user_client.close()


app = FastAPI(
    title="PawPal Composite Service API",
    description="Composite microservice that orchestrates Walk, User, and Review services with foreign key constraints and parallel execution.",
    version="1.0.0",
    lifespan=lifespan
)


def get_walk_client() -> WalkServiceClient:
    """Dependency to get the walk service client."""
    if walk_client is None:
        raise HTTPException(status_code=503, detail="Service not initialized")
    return walk_client


def get_review_client() -> ReviewServiceClient:
    """Dependency to get the review service client."""
    if review_client is None:
        raise HTTPException(status_code=503, detail="Service not initialized")
    return review_client


def get_user_client() -> UserServiceClient:
    """Dependency to get the user service client."""
    if user_client is None:
        raise HTTPException(status_code=503, detail="Service not initialized")
    return user_client


# ============================================================================
# ROOT ENDPOINT
# ============================================================================

@app.get("/")
def root():
    return {
        "message": "Welcome to the PawPal Composite Service API. See /docs for details.",
        "atomic_services": {
            "walk": walk_service_url,
            "review": review_service_url,
            "user": user_service_url
        }
    }


# ============================================================================
# WALK ENDPOINTS - Delegated to Walk Service
# ============================================================================

@app.post("/walks", response_model=WalkRead, status_code=201)
async def create_walk(walk: WalkCreate, client: WalkServiceClient = Depends(get_walk_client)):
    """Create a walk - delegated to Walk service."""
    return await client.create_walk(walk)


@app.get("/walks", response_model=List[WalkRead])
async def list_walks(
    owner_id: Optional[UUID] = Query(None),
    city: Optional[str] = Query(None),
    status: Optional[str] = Query(None),
    client: WalkServiceClient = Depends(get_walk_client)
):
    """List walks - delegated to Walk service."""
    return await client.list_walks(owner_id=owner_id, city=city, status=status)


@app.get("/walks/{walk_id}", response_model=WalkRead)
async def get_walk(walk_id: UUID, client: WalkServiceClient = Depends(get_walk_client)):
    """Get a walk - delegated to Walk service."""
    walk = await client.get_walk(walk_id)
    if walk is None:
        raise HTTPException(status_code=404, detail="Walk not found")
    return walk


@app.patch("/walks/{walk_id}", response_model=WalkRead)
async def update_walk(
    walk_id: UUID,
    update: WalkUpdate,
    client: WalkServiceClient = Depends(get_walk_client)
):
    """Update a walk - delegated to Walk service."""
    return await client.update_walk(walk_id, update)


@app.delete("/walks/{walk_id}", status_code=204)
async def delete_walk(walk_id: UUID, client: WalkServiceClient = Depends(get_walk_client)):
    """Delete a walk - delegated to Walk service."""
    deleted = await client.delete_walk(walk_id)
    if not deleted:
        raise HTTPException(status_code=404, detail="Walk not found")
    return None


# ============================================================================
# REVIEW ENDPOINTS - Delegated to Review Service with FK validation
# ============================================================================

@app.post("/reviews", response_model=Review, status_code=201)
async def create_review(
    review: ReviewCreate,
    walk_cli: WalkServiceClient = Depends(get_walk_client),
    review_cli: ReviewServiceClient = Depends(get_review_client),
    user_cli: UserServiceClient = Depends(get_user_client)
):
    """
    Create a review with foreign key constraint validation.
    Validates that walkId, ownerId, and walkerId exist before creating the review.
    """
    # Foreign key constraint validation
    await validate_review_foreign_keys(
        walk_cli,
        user_cli,
        review.walkId,
        review.ownerId,
        review.walkerId
    )
    
    return await review_cli.create_review(review)


@app.get("/reviews", response_model=Dict[str, Any])
async def list_reviews(
    walkerId: Optional[str] = Query(None),
    ownerId: Optional[str] = Query(None),
    walkId: Optional[str] = Query(None),
    minRating: Optional[float] = Query(None),
    maxRating: Optional[float] = Query(None),
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    client: ReviewServiceClient = Depends(get_review_client)
):
    """List reviews - delegated to Review service."""
    return await client.list_reviews(
        walkerId=walkerId,
        ownerId=ownerId,
        walkId=walkId,
        minRating=minRating,
        maxRating=maxRating,
        page=page,
        limit=limit
    )


@app.get("/reviews/{review_id}", response_model=Review)
async def get_review(review_id: str, client: ReviewServiceClient = Depends(get_review_client)):
    """Get a review - delegated to Review service."""
    review = await client.get_review(review_id)
    if review is None:
        raise HTTPException(status_code=404, detail="Review not found")
    return review


@app.patch("/reviews/{review_id}", response_model=Review)
async def update_review(
    review_id: str,
    update: ReviewUpdate,
    client: ReviewServiceClient = Depends(get_review_client)
):
    """Update a review - delegated to Review service."""
    return await client.update_review(review_id, update)


@app.delete("/reviews/{review_id}", status_code=204)
async def delete_review(review_id: str, client: ReviewServiceClient = Depends(get_review_client)):
    """Delete a review - delegated to Review service."""
    deleted = await client.delete_review(review_id)
    if not deleted:
        raise HTTPException(status_code=404, detail="Review not found")
    return None


# ============================================================================
# USER ENDPOINTS - Delegated to User Service
# ============================================================================

@app.get("/users", response_model=Dict[str, Any])
async def list_users(
    role: Optional[str] = Query(None),
    location: Optional[str] = Query(None),
    limit: Optional[int] = Query(None),
    offset: Optional[int] = Query(None),
    client: UserServiceClient = Depends(get_user_client)
):
    """List users - delegated to User service."""
    return await client.list_users(role=role, location=location, limit=limit, offset=offset)


@app.get("/users/{user_id}", response_model=User)
async def get_user(user_id: str, client: UserServiceClient = Depends(get_user_client)):
    """Get a user - delegated to User service."""
    user = await client.get_user(user_id)
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return user


@app.get("/users/{user_id}/dogs", response_model=List[Dog])
async def get_user_dogs(user_id: str, client: UserServiceClient = Depends(get_user_client)):
    """Get dogs for a user - delegated to User service."""
    return await client.get_user_dogs(user_id)


# ============================================================================
# ORCHESTRATED ENDPOINTS - Composite operations with parallel execution
# ============================================================================

@app.get("/walks/{walk_id}/complete", response_model=Dict[str, Any])
async def get_walk_complete(
    walk_id: UUID,
    walk_cli: WalkServiceClient = Depends(get_walk_client),
    review_cli: ReviewServiceClient = Depends(get_review_client)
):
    """
    Get complete walk information including reviews.
    Uses thread-based parallel execution to fetch walk and reviews simultaneously.
    
    This demonstrates parallel execution using ThreadPoolExecutor.
    """
    # Validate walk exists first
    walk = await walk_cli.get_walk(walk_id)
    if walk is None:
        raise HTTPException(status_code=404, detail="Walk not found")
    
    # Use threads for parallel execution
    def fetch_reviews():
        """Fetch reviews in a thread."""
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(
                review_cli.list_reviews(walkId=str(walk_id))
            )
        finally:
            loop.close()
    
    # Execute review fetch in parallel using threads
    with ThreadPoolExecutor(max_workers=1) as executor:
        reviews_future = executor.submit(fetch_reviews)
        reviews_data = reviews_future.result()
    
    reviews = reviews_data.get("data", []) if isinstance(reviews_data, dict) else reviews_data
    
    return {
        "walk": walk.model_dump(),
        "reviews": reviews,
        "summary": {
            "review_count": len(reviews) if isinstance(reviews, list) else 0
        }
    }


@app.get("/users/{user_id}/complete", response_model=Dict[str, Any])
async def get_user_complete(
    user_id: str,
    user_cli: UserServiceClient = Depends(get_user_client),
    review_cli: ReviewServiceClient = Depends(get_review_client)
):
    """
    Get complete user information including dogs and reviews.
    Uses thread-based parallel execution to fetch user, dogs, and reviews simultaneously.
    
    This demonstrates parallel execution using ThreadPoolExecutor.
    """
    # Use threads for parallel execution
    def fetch_user():
        """Fetch user in a thread."""
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(user_cli.get_user(user_id))
        finally:
            loop.close()
    
    def fetch_dogs():
        """Fetch dogs in a thread."""
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(user_cli.get_user_dogs(user_id))
        finally:
            loop.close()
    
    def fetch_reviews():
        """Fetch reviews in a thread."""
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            # Fetch reviews where user is owner or walker
            owner_reviews = loop.run_until_complete(
                review_cli.list_reviews(ownerId=user_id)
            )
            walker_reviews = loop.run_until_complete(
                review_cli.list_reviews(walkerId=user_id)
            )
            return {
                "as_owner": owner_reviews.get("data", []) if isinstance(owner_reviews, dict) else owner_reviews,
                "as_walker": walker_reviews.get("data", []) if isinstance(walker_reviews, dict) else walker_reviews
            }
        finally:
            loop.close()
    
    # Execute all operations in parallel using threads
    with ThreadPoolExecutor(max_workers=3) as executor:
        user_future = executor.submit(fetch_user)
        dogs_future = executor.submit(fetch_dogs)
        reviews_future = executor.submit(fetch_reviews)
        
        # Wait for all to complete
        user = user_future.result()
        dogs = dogs_future.result()
        reviews = reviews_future.result()
    
    if user is None:
        raise HTTPException(status_code=404, detail="User not found")
    
    return {
        "user": user.model_dump(),
        "dogs": [dog.model_dump() for dog in dogs],
        "reviews": reviews,
        "summary": {
            "dog_count": len(dogs),
            "reviews_as_owner": len(reviews.get("as_owner", [])),
            "reviews_as_walker": len(reviews.get("as_walker", []))
        }
    }


@app.get("/reviews/{review_id}/complete", response_model=Dict[str, Any])
async def get_review_complete(
    review_id: str,
    review_cli: ReviewServiceClient = Depends(get_review_client),
    walk_cli: WalkServiceClient = Depends(get_walk_client),
    user_cli: UserServiceClient = Depends(get_user_client)
):
    """
    Get complete review information including walk, owner, and walker details.
    Uses thread-based parallel execution to fetch all related data simultaneously.
    
    This demonstrates parallel execution using ThreadPoolExecutor.
    """
    # Get review first
    review = await review_cli.get_review(review_id)
    if review is None:
        raise HTTPException(status_code=404, detail="Review not found")
    
    # Use threads for parallel execution
    def fetch_walk():
        """Fetch walk in a thread."""
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            walk_uuid = UUID(review.walkId)
            return loop.run_until_complete(walk_cli.get_walk(walk_uuid))
        except ValueError:
            return None
        finally:
            loop.close()
    
    def fetch_owner():
        """Fetch owner in a thread."""
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(user_cli.get_user(review.ownerId))
        finally:
            loop.close()
    
    def fetch_walker():
        """Fetch walker in a thread."""
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            return loop.run_until_complete(user_cli.get_user(review.walkerId))
        finally:
            loop.close()
    
    # Execute all operations in parallel using threads
    with ThreadPoolExecutor(max_workers=3) as executor:
        walk_future = executor.submit(fetch_walk)
        owner_future = executor.submit(fetch_owner)
        walker_future = executor.submit(fetch_walker)
        
        # Wait for all to complete
        walk = walk_future.result()
        owner = owner_future.result()
        walker = walker_future.result()
    
    return {
        "review": review.model_dump(),
        "walk": walk.model_dump() if walk else None,
        "owner": owner.model_dump() if owner else None,
        "walker": walker.model_dump() if walker else None
    }


# ============================================================================
# Error Handlers
# ============================================================================

@app.exception_handler(ForeignKeyConstraintError)
async def foreign_key_constraint_handler(request, exc: ForeignKeyConstraintError):
    """Handle foreign key constraint violations."""
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": "Foreign Key Constraint Violation", "detail": exc.detail}
    )


if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=port, reload=True)

